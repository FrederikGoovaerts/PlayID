include <LTC>

/**
 * This FO(.) file was generated with PlayID.
 * PlayID is a program made by Frederik Goovaerts and Thomas Winters.
 */

LTCvocabulary V {
	// Default vocabulary elements (and types needed by the default elements)
	type Time isa nat
	Start : Time
	partial Next(Time) : Time
	type Type2 constructed from { a, b }
	type Action constructed from { choose(Type2) }
	terminalTime(Time)
	type ScoreType isa nat
	type Player constructed from { player }
	Score(Player) : ScoreType
	do(Time, Player, Action)
	fodot_legal_move(Time, Player, Action)
	
	// Vocabulary elements derived from GDL file
	type Type1 isa int
	
	// Static predicates
	succ(Type1, Type1)
	
	// Dynamic predicates
	step(Time, Type1)
	chosen(Time, Type2)
	unchosen(Time, Type2)
	
	// LTC predicates for the fluent predicates
	I_step(Type1)
	C_step(Time, Type1)
	
	I_chosen(Type2)
	C_chosen(Time, Type2)
	
	I_unchosen(Type2)
	C_unchosen(Time, Type2)
	
}

theory T : V {
	// Default theory elements:
	! a2 [Action] p [Player] t [Time] : do(t, p, a2) => ~terminalTime(t) & (? t2 [Time] : Next(t) = t2).
	! p [Player] t [Time] : ~terminalTime(t) & (? t2 [Time] : Next(t) = t2) => (?=1 a2 [Action] : do(t, p, a2)).
	{
		! t [Time] : Next(t) = t + 1 <- ~terminalTime(t) & (? t2 [Time] : Next(t2) = t).
		Next(0) = 1.
	}
	! a2 [Action] p [Player] t [Time] : do(t, p, a2) => fodot_legal_move(t, p, a2).
	
	// Inductive definitions for the fluent predicates
	{
		! t [Type1] : step(Start, t) <- I_step(t).
		! t [Type1] t2 [Time] : step(Next(t2), t) <- C_step(t2, t).
	}
	{
		! t [Type2] : chosen(Start, t) <- I_chosen(t).
		! t [Type2] t2 [Time] : chosen(Next(t2), t) <- C_chosen(t2, t).
	}
	{
		! t [Type2] : unchosen(Start, t) <- I_unchosen(t).
		! t [Type2] t2 [Time] : unchosen(Next(t2), t) <- C_unchosen(t2, t).
	}
	
	// The fluent predicates' causations
	{
		! t [Time] x [Type2] : C_chosen(t, x) <- do(t, player, choose(x)).
	}
	{
		! t [Time] x [Type2] y [Type2] : C_unchosen(t, x) <- do(t, player, choose(y)) & unchosen(t, x) & x ~= y.
	}
	{
		! t [Time] x [Type1] y [Type1] : C_step(t, y) <- step(t, x) & succ(x, y).
	}
	
	// Translation of the LEGAL sentences
	{
		! t [Time] x [Type2] : fodot_legal_move(t, player, choose(x)) <- unchosen(t, x).
	}
	
	// Translation of the SCORE sentences
	{
		Score(player) = 0 <- ! t [Time] : terminalTime(t) => chosen(t, b).
		Score(player) = 100 <- ! t [Time] : terminalTime(t) => chosen(t, a).
	}
	
	// Translation of the TERMINAL sentences
	{
		! t [Time] : terminalTime(t) <- step(t, 2).
		! t [Time] x [Type2] : terminalTime(t) <- chosen(t, x).
	}
}

structure S : V {
	// Default structure elements:
	Start = 0
	Time = { 0..40 }
	ScoreType = { 0..100 }
	
	// Elements found by in first phase
	Type1 = { 1..2 }
	
	// Desired result
	Score = { player->100 }
	
	// Initial values for the fluent predicates
	I_step = { 1 }
	I_unchosen = { a; b }
	
	// All values found in the static predicates
	succ = { 1,2 }
}

procedure main() {
	stdoptions.timeout=15
	stdoptions.nbmodels=5
	printmodels(modelexpand(T,S))
}