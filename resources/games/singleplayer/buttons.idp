include <LTC>

LTCvocabulary V {
	// Default vocabulary elements (and types needed by the default elements)
	type Time isa nat
	Start : Time
	partial Next(Time) : Time
	type Action constructed from {a,c,b}
	terminalTime(Time)
	type ScoreType isa nat
	type Player constructed from {p_robot}
	Score(Player) : ScoreType
	do(Time,Player,Action)
	
	// Vocabulary elements derived from GDL file
	type All constructed from {r,p,q,i5,i6,i7,i1,i2,i3,i4}
	successor(All,All)
	
	// LTC predicates for the fluent predicates
	off(Time,All)
	I_off(All)
	C_off(Time,All)
	
	on(Time,All)
	I_on(All)
	C_on(Time,All)
	
	step(Time,All)
	I_step(All)
	C_step(Time,All)
	
}
theory T: V {
	// Default theory elements:
	! a [Action] t [Time] p [Player]  : do(t,p,a) => ~terminalTime(t) & (? t2 [Time]  : Next(t) = t2).
	! p [Player] t [Time]  : ~terminalTime(t) & (? t2 [Time]  : Next(t) = t2) => (?=1 a [Action]  : do(t,p,a)).
	{
		! t [Time]  : Next(t) = t + 1 <- ~terminalTime(t) & (? t2 [Time]  : Next(t2) = t).
		Next(0) = 1.
	}
	
	// Inductive definitions for the fluent predicates
	{
		! a [All]  : off(Start,a) <- I_off(a).
		! a [All] t [Time]  : off(Next(t),a) <- C_off(t,a).
	}
	{
		! a [All]  : on(Start,a) <- I_on(a).
		! a [All] t [Time]  : on(Next(t),a) <- C_on(t,a).
	}
	{
		! a [All]  : step(Start,a) <- I_step(a).
		! a [All] t [Time]  : step(Next(t),a) <- C_step(t,a).
	}
	
	// The fluent predicates' causations
	{
		! t [Time]  : C_on(t,r) <- do(t,p_robot,a) & on(t,r).
		! t [Time]  : C_on(t,r) <- do(t,p_robot,b) & on(t,r).
		! t [Time]  : C_on(t,q) <- do(t,p_robot,b) & on(t,p).
		! t [Time]  : C_on(t,p) <- do(t,p_robot,b) & on(t,q).
		! t [Time]  : C_on(t,r) <- do(t,p_robot,c) & on(t,q).
		! t [Time]  : C_on(t,q) <- do(t,p_robot,c) & on(t,r).
		! t [Time]  : C_on(t,p) <- do(t,p_robot,a) & off(t,p).
		! t [Time]  : C_on(t,q) <- do(t,p_robot,a) & on(t,q).
		! t [Time]  : C_on(t,p) <- do(t,p_robot,c) & on(t,p).
	}
	{
		! y [All] x [All] t [Time]  : C_step(t,y) <- step(t,x) & successor(x,y).
	}
	{
		! t [Time]  : C_off(t,r) <- do(t,p_robot,a) & off(t,r).
		! t [Time]  : C_off(t,q) <- do(t,p_robot,b) & off(t,p).
		! t [Time]  : C_off(t,p) <- do(t,p_robot,b) & off(t,q).
		! t [Time]  : C_off(t,p) <- do(t,p_robot,c) & off(t,p).
		! t [Time]  : C_off(t,q) <- do(t,p_robot,a) & off(t,q).
		! t [Time]  : C_off(t,r) <- do(t,p_robot,b) & off(t,r).
		! t [Time]  : C_off(t,p) <- do(t,p_robot,a) & on(t,p).
		! t [Time]  : C_off(t,r) <- do(t,p_robot,c) & off(t,q).
		! t [Time]  : C_off(t,q) <- do(t,p_robot,c) & off(t,r).
	}
	
	// Translation of the SCORE sentences
	{
		Score(p_robot) = 100 <- ! t [Time]  : terminalTime(t) => on(t,p) & on(t,q) & on(t,r).
		Score(p_robot) = 0 <- ! t [Time]  : terminalTime(t) => ~on(t,p).
		Score(p_robot) = 0 <- ! t [Time]  : terminalTime(t) => ~on(t,q).
		Score(p_robot) = 0 <- ! t [Time]  : terminalTime(t) => ~on(t,r).
	}
	
	// Translation of the TERMINAL sentences
	{
		! t [Time]  : terminalTime(t) <- step(t,i7).
		! t [Time]  : terminalTime(t) <- on(t,p) & on(t,q) & on(t,r).
	}
}
structure S : V {
	// Default structure elements:
	Start = 0
	Time = {0..20}
	ScoreType = {0..100}
	
	// Desired result
	Score = {p_robot->100}
	
	// Initial values for the fluent predicates
	I_step = {i1}
	I_off = {p;q;r}
	
	// All values found in the static predicates
	successor = {i3,i4;i2,i3;i5,i6;i4,i5;i6,i7;i1,i2}
}
procedure main() {
	stdoptions.nbmodels=5
	printmodels(modelexpand(T,S))
}
