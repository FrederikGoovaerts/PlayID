include <LTC>

LTCvocabulary V {
	// Default vocabulary elements (and types needed by the default elements)
	type Time isa nat
	Start : Time
	partial Next(Time) : Time
	type All constructed from {i47,i48,i49,i43,i44,i45,i46,i40,i41,i42,i5,i15,i6,i14,i17,i7,i16,i8,i1,i11,i2,i10,i3,i13,i4,i12,i58,i59,i18,i56,i19,i9,i57,i54,i55,i52,i53,i50,i51,i20,i24,i23,i22,i21,i28,i27,i26,i25,i29,i60,i61,i62,i63,i64,g,f,e,d,c,b,i31,a,i30,i33,o,i32,i35,i34,i37,k,i36,i39,i38,h}
	type Action constructed from {move(All,All)}
	terminalTime(Time)
	type ScoreType isa nat
	type Player constructed from {p_player}
	Score(Player) : ScoreType
	do(Time,Player,Action)
	
	// Vocabulary elements derived from GDL file
	succ(All,All)
	nextcolumn(All,All)
	adjacent(All,All)
	existslegalmove(Time)
	knightmove(Time,All,All,All,All)
	smaller(Time,All,All)
	
	// LTC predicates for the fluent predicates
	cell(Time,All,All,All)
	I_cell(All,All,All)
	C_cell(Time,All,All,All)
	
	step(Time,All)
	I_step(All)
	C_step(Time,All)
	
}
theory T: V {
	// Default theory elements:
	! a [Action] t [Time] p [Player]  : do(t,p,a) => ~terminalTime(t) & (? t2 [Time]  : Next(t) = t2).
	! p [Player] t [Time]  : ~terminalTime(t) & (? t2 [Time]  : Next(t) = t2) => (?=1 a [Action]  : do(t,p,a)).
	{
		! t [Time]  : Next(t) = t + 1 <- ~terminalTime(t) & (? t2 [Time]  : Next(t2) = t).
		Next(0) = 1.
	}
	
	// Inductive definitions for the fluent predicates
	{
		! a [All] a3 [All] a2 [All]  : cell(Start,a,a2,a3) <- I_cell(a,a2,a3).
		! a [All] a3 [All] t [Time] a2 [All]  : cell(Next(t),a,a2,a3) <- C_cell(t,a,a2,a3).
	}
	{
		! a [All]  : step(Start,a) <- I_step(a).
		! a [All] t [Time]  : step(Next(t),a) <- C_step(t,a).
	}
	
	// The fluent predicates' causations
	{
		! y [All] x [All] t [Time]  : C_step(t,y) <- step(t,x) & succ(x,y).
	}
	{
		! y [All] x [All] t [Time]  : C_cell(t,x,y,b) <- cell(t,x,y,b) & ~do(t,p_player,move(x,y)).
		! y [All] x [All] t [Time]  : C_cell(t,x,y,o) <- cell(t,x,y,k).
		! y [All] x [All] t [Time]  : C_cell(t,x,y,o) <- cell(t,x,y,o).
		! y [All] x [All] t [Time]  : C_cell(t,x,y,k) <- do(t,p_player,move(x,y)).
	}
	
	// The static predicates' causations
	{
		! z [All] y [All] x [All] t [Time]  : smaller(t,x,y) <- succ(z,y) & smaller(t,x,z).
		! y [All] x [All] t [Time]  : smaller(t,x,y) <- succ(x,y).
	}
	{
		! y [All] x [All] v [All] w [All] t [Time] u [All]  : knightmove(t,u,v,x,y) <- nextcolumn(u,x) & adjacent(v,w) & adjacent(w,y).
		! y [All] x [All] v [All] w [All] t [Time] u [All]  : knightmove(t,u,v,x,y) <- nextcolumn(x,w) & nextcolumn(w,u) & adjacent(v,y).
		! y [All] x [All] v [All] w [All] t [Time] u [All]  : knightmove(t,u,v,x,y) <- nextcolumn(u,w) & nextcolumn(w,x) & adjacent(v,y).
		! y [All] x [All] v [All] w [All] t [Time] u [All]  : knightmove(t,u,v,x,y) <- nextcolumn(x,u) & adjacent(y,w) & adjacent(w,v).
		! y [All] x [All] v [All] w [All] t [Time] u [All]  : knightmove(t,u,v,x,y) <- nextcolumn(u,w) & nextcolumn(w,x) & adjacent(y,v).
		! y [All] x [All] v [All] w [All] t [Time] u [All]  : knightmove(t,u,v,x,y) <- nextcolumn(x,w) & nextcolumn(w,u) & adjacent(y,v).
		! y [All] x [All] v [All] w [All] t [Time] u [All]  : knightmove(t,u,v,x,y) <- nextcolumn(x,u) & adjacent(v,w) & adjacent(w,y).
		! y [All] x [All] v [All] w [All] t [Time] u [All]  : knightmove(t,u,v,x,y) <- nextcolumn(u,x) & adjacent(y,w) & adjacent(w,v).
	}
	{
		! y [All] x [All] v [All] t [Time] u [All]  : existslegalmove(t) <- cell(t,u,v,k) & cell(t,x,y,b) & knightmove(t,u,v,x,y).
	}
	
	// Translation of the LEGAL sentences
	! y [All] x [All] v [All] t [Time] u [All]  : do(t,p_player,move(x,y)) => cell(t,u,v,k) & cell(t,x,y,b) & knightmove(t,u,v,x,y).
	
	// Translation of the SCORE sentences
	{
		Score(p_player) = 100 <- ! t [Time]  : terminalTime(t) => step(t,i64).
		Score(p_player) = 70 <- ! t [Time]  : terminalTime(t) => (? x [All]  : step(t,x) & smaller(t,x,i60) & smaller(t,i55,x)).
		Score(p_player) = 40 <- ! t [Time]  : terminalTime(t) => (? x [All]  : step(t,x) & smaller(t,x,i48) & smaller(t,i43,x)).
		Score(p_player) = 10 <- ! t [Time]  : terminalTime(t) => (? x [All]  : step(t,x) & smaller(t,x,i36) & smaller(t,i31,x)).
		Score(p_player) = 80 <- ! t [Time]  : terminalTime(t) => (? x [All]  : step(t,x) & smaller(t,x,i62) & smaller(t,i59,x)).
		Score(p_player) = 50 <- ! t [Time]  : terminalTime(t) => (? x [All]  : step(t,x) & smaller(t,x,i52) & smaller(t,i47,x)).
		Score(p_player) = 30 <- ! t [Time]  : terminalTime(t) => (? x [All]  : step(t,x) & smaller(t,x,i44) & smaller(t,i39,x)).
		Score(p_player) = 60 <- ! t [Time]  : terminalTime(t) => (? x [All]  : step(t,x) & smaller(t,x,i56) & smaller(t,i51,x)).
		Score(p_player) = 0 <- ! t [Time]  : terminalTime(t) => (? x [All]  : step(t,x) & smaller(t,x,i32)).
		Score(p_player) = 20 <- ! t [Time]  : terminalTime(t) => (? x [All]  : step(t,x) & smaller(t,x,i40) & smaller(t,i35,x)).
		Score(p_player) = 90 <- ! t [Time]  : terminalTime(t) => (? x [All]  : step(t,x) & smaller(t,x,i64) & smaller(t,i61,x)).
	}
	
	// Translation of the TERMINAL sentences
	{
		! t [Time]  : terminalTime(t) <- ~existslegalmove(t).
	}
}
structure S : V {
	// Default structure elements:
	Start = 0
	Time = {0..20}
	ScoreType = {0..100}
	
	// Desired result
	Score = {p_player->100}
	
	// Initial values for the fluent predicates
	I_step = {i1}
	I_cell = {e,i3,b;h,i6,b;b,i4,b;c,i8,b;c,i4,b;d,i3,b;g,i7,b;f,i3,b;e,i7,b;a,i4,b;d,i7,b;h,i3,b;a,i7,b;g,i3,b;f,i7,b;c,i5,b;b,i1,b;h,i1,b;b,i5,b;h,i7,b;e,i2,b;d,i2,b;f,i2,b;g,i6,b;c,i1,b;d,i6,b;e,i6,b;a,i5,b;a,i6,b;f,i6,b;h,i2,b;g,i2,b;b,i6,b;h,i4,b;b,i2,b;e,i5,b;h,i8,b;c,i2,b;a,i1,k;e,i1,b;c,i6,b;d,i1,b;a,i2,b;d,i5,b;f,i1,b;f,i5,b;g,i5,b;b,i7,b;g,i1,b;h,i5,b;b,i3,b;e,i4,b;c,i3,b;f,i8,b;c,i7,b;e,i8,b;d,i4,b;b,i8,b;g,i8,b;d,i8,b;g,i4,b;a,i8,b;f,i4,b;a,i3,b}
	
	// All values found in the static predicates
	succ = {i51,i52;i37,i38;i59,i60;i60,i61;i10,i11;i46,i47;i33,i34;i23,i24;i18,i19;i4,i5;i55,i56;i27,i28;i42,i43;i14,i15;i8,i9;i38,i39;i52,i53;i47,i48;i61,i62;i34,i35;i1,i2;i22,i23;i30,i31;i17,i18;i5,i6;i56,i57;i26,i27;i13,i14;i43,i44;i44,i45;i53,i54;i62,i63;i29,i30;i48,i49;i21,i22;i35,i36;i39,i40;i16,i17;i2,i3;i31,i32;i25,i26;i19,i20;i40,i41;i6,i7;i12,i13;i57,i58;i45,i46;i54,i55;i63,i64;i36,i37;i50,i51;i20,i21;i15,i16;i3,i4;i24,i25;i32,i33;i9,i10;i7,i8;i11,i12;i41,i42;i58,i59;i28,i29;i49,i50}
	adjacent = {i3,i4;i2,i3;i5,i6;i4,i5;i7,i8;i6,i7;i1,i2}
	nextcolumn = {f,g;e,f;g,h;b,c;a,b;d,e;c,d}
}
procedure main() {
	stdoptions.nbmodels=5
	printmodels(modelexpand(T,S))
}
