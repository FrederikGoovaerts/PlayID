include <LTC>

LTCvocabulary V {
	// Default vocabulary elements (and types needed by the default elements)
	type Time isa nat
	Start : Time
	partial Next(Time) : Time
	type All constructed from {i20,i24,i23,i22,i21,i28,i27,i26,i25,i29,i0,b,i30,i15,o,i5,i14,i6,i17,i7,i16,i8,i11,i1,i10,i2,i13,i3,i12,i4,i18,i19,i9}
	type Action constructed from {kill(All,All)}
	terminalTime(Time)
	type ScoreType isa nat
	type Player constructed from {p_robot}
	Score(Player) : ScoreType
	do(Time,Player,Action)
	
	// Vocabulary elements derived from GDL file
	succ(All,All)
	rcpred(All,All)
	rcsucc(All,All)
	any_occupied(Time)
	countalive(Time,All,All,All,All)
	clear(Time)
	number(Time,All)
	countifalive(Time,All,All,All,All)
	smaller(Time,All,All)
	countneighbours(Time,All,All,All,All)
	
	// LTC predicates for the fluent predicates
	cell(Time,All,All,All)
	I_cell(All,All,All)
	C_cell(Time,All,All,All)
	
	step(Time,All)
	I_step(All)
	C_step(Time,All)
	
}
theory T: V {
	// Default theory elements:
	! a [Action] t [Time] p [Player]  : do(t,p,a) => ~terminalTime(t) & (? t2 [Time]  : Next(t) = t2).
	! p [Player] t [Time]  : ~terminalTime(t) & (? t2 [Time]  : Next(t) = t2) => (?=1 a [Action]  : do(t,p,a)).
	{
		! t [Time]  : Next(t) = t + 1 <- ~terminalTime(t) & (? t2 [Time]  : Next(t2) = t).
		Next(0) = 1.
	}
	
	// Inductive definitions for the fluent predicates
	{
		! a [All] a3 [All] a2 [All]  : cell(Start,a,a2,a3) <- I_cell(a,a2,a3).
		! a [All] a3 [All] t [Time] a2 [All]  : cell(Next(t),a,a2,a3) <- C_cell(t,a,a2,a3).
	}
	{
		! a [All]  : step(Start,a) <- I_step(a).
		! a [All] t [Time]  : step(Next(t),a) <- C_step(t,a).
	}
	
	// The fluent predicates' causations
	{
		! y [All] x [All] t [Time]  : C_step(t,y) <- step(t,x) & succ(x,y).
	}
	{
		! y [All] x [All] t [Time]  : C_cell(t,x,y,b) <- cell(t,x,y,b) & ~do(t,p_robot,kill(x,y)) & countneighbours(t,x,y,i0,i2).
		! y [All] x [All] n [All] t [Time] c [All]  : C_cell(t,x,y,b) <- cell(t,x,y,c) & ~do(t,p_robot,kill(x,y)) & countneighbours(t,x,y,i0,n) & n ~= i2 & n ~= i3 & n ~= i4 & n ~= i5.
		! y [All] x [All] t [Time]  : C_cell(t,x,y,b) <- do(t,p_robot,kill(x,y)).
		! y [All] x [All] t [Time] c [All]  : C_cell(t,x,y,o) <- cell(t,x,y,c) & ~do(t,p_robot,kill(x,y)) & countneighbours(t,x,y,i0,i3).
		! y [All] x [All] t [Time] c [All]  : C_cell(t,x,y,o) <- cell(t,x,y,c) & ~do(t,p_robot,kill(x,y)) & countneighbours(t,x,y,i0,i4).
		! y [All] x [All] t [Time]  : C_cell(t,x,y,o) <- cell(t,x,y,o) & ~do(t,p_robot,kill(x,y)) & countneighbours(t,x,y,i0,i2).
		! y [All] x [All] t [Time] c [All]  : C_cell(t,x,y,o) <- cell(t,x,y,c) & ~do(t,p_robot,kill(x,y)) & countneighbours(t,x,y,i0,i5).
	}
	
	// The static predicates' causations
	{
		! y [All] x [All] c1 [All] c6 [All] ys [All] c2 [All] yp [All] n [All] s [All] c7 [All] c3 [All] c4 [All] xs [All] xp [All] t [Time] c5 [All]  : countneighbours(t,x,y,n,s) <- rcpred(x,xp) & rcpred(y,yp) & rcsucc(x,xs) & rcsucc(y,ys) & countifalive(t,xp,yp,n,c1) & countifalive(t,x,yp,c1,c2) & countifalive(t,xs,yp,c2,c3) & countifalive(t,xp,y,c3,c4) & countifalive(t,xs,y,c4,c5) & countifalive(t,xs,ys,c5,c6) & countifalive(t,x,ys,c6,c7) & countifalive(t,xp,ys,c7,s).
	}
	{
		! y [All] z [All] x [All] t [Time]  : smaller(t,x,z) <- succ(y,z) & smaller(t,x,y).
		! y [All] x [All] t [Time]  : smaller(t,x,y) <- succ(x,y).
	}
	{
		! y [All] x [All] t [Time]  : number(t,x) <- succ(x,y).
		! y [All] x [All] t [Time]  : number(t,y) <- succ(x,y).
	}
	{
		! y [All] x [All] i [All] t [Time] c [All]  : countifalive(t,x,y,i,i) <- cell(t,x,y,c) & c ~= o & number(t,i).
		! y [All] x [All] i [All] t [Time] o [All]  : countifalive(t,x,y,i,o) <- cell(t,x,y,o) & succ(i,o).
	}
	{
		! n1 [All] n [All] t [Time]  : countalive(t,i5,i5,n1,n) <- countifalive(t,i5,i5,n1,n).
		! x [All] n2 [All] x1 [All] n1 [All] n [All] t [Time]  : countalive(t,x,i5,n1,n) <- rcsucc(x,x1) & x ~= i5 & countifalive(t,x,i5,n1,n2) & countalive(t,x1,i1,n2,n).
		! y [All] y1 [All] x [All] n2 [All] n1 [All] n [All] t [Time]  : countalive(t,x,y,n1,n) <- rcsucc(y,y1) & y ~= i5 & countifalive(t,x,y,n1,n2) & countalive(t,x,y1,n2,n).
	}
	{
		! t [Time]  : clear(t) <- ~any_occupied(t).
	}
	{
		! y [All] x [All] t [Time]  : any_occupied(t) <- cell(t,x,y,o).
	}
	
	// Translation of the LEGAL sentences
	! y [All] x [All] t [Time]  : do(t,p_robot,kill(x,y)) => cell(t,x,y,o).
	
	// Translation of the SCORE sentences
	{
		Score(p_robot) = 100 <- ! t [Time]  : terminalTime(t) => countalive(t,i1,i1,i0,i0).
		Score(p_robot) = 40 <- ! t [Time]  : terminalTime(t) => (? n [All]  : countalive(t,i1,i1,i0,n) & smaller(t,i10,n) & smaller(t,n,i16)).
		Score(p_robot) = 0 <- ! t [Time]  : terminalTime(t) => (? n [All]  : countalive(t,i1,i1,i0,n) & smaller(t,i20,n)).
		Score(p_robot) = 80 <- ! t [Time]  : terminalTime(t) => (? n [All]  : countalive(t,i1,i1,i0,n) & n ~= i0 & smaller(t,n,i6)).
		Score(p_robot) = 20 <- ! t [Time]  : terminalTime(t) => (? n [All]  : countalive(t,i1,i1,i0,n) & smaller(t,i15,n) & smaller(t,n,i21)).
		Score(p_robot) = 60 <- ! t [Time]  : terminalTime(t) => (? n [All]  : countalive(t,i1,i1,i0,n) & smaller(t,i5,n) & smaller(t,n,i11)).
	}
	
	// Translation of the TERMINAL sentences
	{
		! t [Time]  : terminalTime(t) <- step(t,i30).
		! t [Time]  : terminalTime(t) <- clear(t).
	}
}
structure S : V {
	// Default structure elements:
	Start = 0
	Time = {0..20}
	ScoreType = {0..100}
	
	// Desired result
	Score = {p_robot->100}
	
	// Initial values for the fluent predicates
	I_step = {i0}
	I_cell = {i4,i5,o;i2,i4,b;i1,i2,o;i3,i2,b;i2,i1,o;i4,i4,b;i3,i3,b;i5,i2,b;i5,i4,b;i3,i5,o;i4,i2,o;i2,i3,b;i1,i5,o;i1,i3,o;i2,i5,b;i5,i1,o;i3,i1,b;i1,i1,o;i4,i1,b;i5,i5,o;i1,i4,b;i5,i3,o;i4,i3,o;i3,i4,o;i2,i2,b}
	
	// All values found in the static predicates
	rcsucc = {i3,i4;i2,i3;i4,i5;i5,i1;i1,i2}
	succ = {i10,i11;i29,i30;i0,i1;i21,i22;i1,i2;i20,i21;i22,i23;i15,i16;i3,i4;i23,i24;i16,i17;i2,i3;i24,i25;i17,i18;i5,i6;i25,i26;i18,i19;i4,i5;i9,i10;i19,i20;i7,i8;i11,i12;i26,i27;i12,i13;i6,i7;i27,i28;i13,i14;i28,i29;i14,i15;i8,i9}
	rcpred = {i2,i1;i5,i4;i1,i5;i3,i2;i4,i3}
}
procedure main() {
	stdoptions.nbmodels=5
	printmodels(modelexpand(T,S))
}
