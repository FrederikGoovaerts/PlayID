include <LTC>

LTCvocabulary V {
	// Default vocabulary elements (and types needed by the default elements)
	type Time isa nat
	Start : Time
	partial Next(Time) : Time
	type Action constructed from {a,c,b}
	terminalTime(Time)
	type ScoreType isa nat
	type Player constructed from {p_robot}
	Score(Player) : ScoreType
	do(Time,Player,Action)
	
	// Vocabulary elements derived from GDL file
	type All
	
	// LTC predicates for the fluent predicates
	p7(Time)
	I_p7()
	C_p7(Time)
	
	p6(Time)
	I_p6()
	C_p6(Time)
	
	p5(Time)
	I_p5()
	C_p5(Time)
	
	p4(Time)
	I_p4()
	C_p4(Time)
	
	p3(Time)
	I_p3()
	C_p3(Time)
	
	p2(Time)
	I_p2()
	C_p2(Time)
	
	p1(Time)
	I_p1()
	C_p1(Time)
	
	p10(Time)
	I_p10()
	C_p10(Time)
	
	p9(Time)
	I_p9()
	C_p9(Time)
	
	p8(Time)
	I_p8()
	C_p8(Time)
	
	p16(Time)
	I_p16()
	C_p16(Time)
	
	p15(Time)
	I_p15()
	C_p15(Time)
	
	p14(Time)
	I_p14()
	C_p14(Time)
	
	p13(Time)
	I_p13()
	C_p13(Time)
	
	p12(Time)
	I_p12()
	C_p12(Time)
	
	p11(Time)
	I_p11()
	C_p11(Time)
	
}
theory T: V {
	// Default theory elements:
	! a [Action] t [Time] p [Player]  : do(t,p,a) => ~terminalTime(t) & (? t2 [Time]  : Next(t) = t2).
	! p [Player] t [Time]  : ~terminalTime(t) & (? t2 [Time]  : Next(t) = t2) => (?=1 a [Action]  : do(t,p,a)).
	{
		! t [Time]  : Next(t) = t + 1 <- ~terminalTime(t) & (? t2 [Time]  : Next(t2) = t).
		Next(0) = 1.
	}
	
	// Inductive definitions for the fluent predicates
	{
		p7(Start) <- I_p7.
		! t [Time]  : p7(Next(t)) <- C_p7(t).
	}
	{
		p6(Start) <- I_p6.
		! t [Time]  : p6(Next(t)) <- C_p6(t).
	}
	{
		p5(Start) <- I_p5.
		! t [Time]  : p5(Next(t)) <- C_p5(t).
	}
	{
		p4(Start) <- I_p4.
		! t [Time]  : p4(Next(t)) <- C_p4(t).
	}
	{
		p3(Start) <- I_p3.
		! t [Time]  : p3(Next(t)) <- C_p3(t).
	}
	{
		p2(Start) <- I_p2.
		! t [Time]  : p2(Next(t)) <- C_p2(t).
	}
	{
		p1(Start) <- I_p1.
		! t [Time]  : p1(Next(t)) <- C_p1(t).
	}
	{
		p10(Start) <- I_p10.
		! t [Time]  : p10(Next(t)) <- C_p10(t).
	}
	{
		p9(Start) <- I_p9.
		! t [Time]  : p9(Next(t)) <- C_p9(t).
	}
	{
		p8(Start) <- I_p8.
		! t [Time]  : p8(Next(t)) <- C_p8(t).
	}
	{
		p16(Start) <- I_p16.
		! t [Time]  : p16(Next(t)) <- C_p16(t).
	}
	{
		p15(Start) <- I_p15.
		! t [Time]  : p15(Next(t)) <- C_p15(t).
	}
	{
		p14(Start) <- I_p14.
		! t [Time]  : p14(Next(t)) <- C_p14(t).
	}
	{
		p13(Start) <- I_p13.
		! t [Time]  : p13(Next(t)) <- C_p13(t).
	}
	{
		p12(Start) <- I_p12.
		! t [Time]  : p12(Next(t)) <- C_p12(t).
	}
	{
		p11(Start) <- I_p11.
		! t [Time]  : p11(Next(t)) <- C_p11(t).
	}
	
	// The fluent predicates' causations
	{
		! t [Time]  : C_p10(t) <- do(t,p_robot,a) & p9(t).
	}
	{
		! t [Time]  : C_p8(t) <- do(t,p_robot,b) & p7(t).
		! t [Time]  : C_p8(t) <- do(t,p_robot,a) & p6(t).
	}
	{
		! t [Time]  : C_p11(t) <- do(t,p_robot,b) & p9(t).
	}
	{
		! t [Time]  : C_p9(t) <- do(t,p_robot,c) & p8(t).
	}
	{
		! t [Time]  : C_p12(t) <- do(t,p_robot,b) & p11(t).
		! t [Time]  : C_p12(t) <- do(t,p_robot,a) & p10(t).
	}
	{
		! t [Time]  : C_p13(t) <- do(t,p_robot,c) & p12(t).
	}
	{
		! t [Time]  : C_p14(t) <- do(t,p_robot,a) & p13(t).
	}
	{
		! t [Time]  : C_p15(t) <- do(t,p_robot,b) & p13(t).
	}
	{
		! t [Time]  : C_p16(t) <- do(t,p_robot,b) & p15(t).
		! t [Time]  : C_p16(t) <- do(t,p_robot,a) & p14(t).
	}
	{
		! t [Time]  : C_p2(t) <- do(t,p_robot,a) & p1(t).
	}
	{
		! t [Time]  : C_p3(t) <- do(t,p_robot,b) & p1(t).
	}
	{
		! t [Time]  : C_p4(t) <- do(t,p_robot,b) & p3(t).
		! t [Time]  : C_p4(t) <- do(t,p_robot,a) & p2(t).
	}
	{
		! t [Time]  : C_p5(t) <- do(t,p_robot,c) & p4(t).
	}
	{
		! t [Time]  : C_p6(t) <- do(t,p_robot,a) & p5(t).
	}
	{
		! t [Time]  : C_p7(t) <- do(t,p_robot,b) & p5(t).
	}
	
	// Translation of the LEGAL sentences
	! t [Time]  : do(t,p_robot,b) => p9(t).
	! t [Time]  : do(t,p_robot,b) => p3(t).
	! t [Time]  : do(t,p_robot,b) => p11(t).
	! t [Time]  : do(t,p_robot,b) => p7(t).
	! t [Time]  : do(t,p_robot,b) => p15(t).
	! t [Time]  : do(t,p_robot,b) => p5(t).
	! t [Time]  : do(t,p_robot,b) => p13(t).
	! t [Time]  : do(t,p_robot,b) => p1(t).
	! t [Time]  : do(t,p_robot,a) => p9(t).
	! t [Time]  : do(t,p_robot,a) => p6(t).
	! t [Time]  : do(t,p_robot,a) => p2(t).
	! t [Time]  : do(t,p_robot,a) => p10(t).
	! t [Time]  : do(t,p_robot,a) => p14(t).
	! t [Time]  : do(t,p_robot,a) => p5(t).
	! t [Time]  : do(t,p_robot,a) => p13(t).
	! t [Time]  : do(t,p_robot,a) => p1(t).
	! t [Time]  : do(t,p_robot,c) => p8(t).
	! t [Time]  : do(t,p_robot,c) => p4(t).
	! t [Time]  : do(t,p_robot,c) => p12(t).
	
	// Translation of the SCORE sentences
	{
		Score(p_robot) = 0 <- ! t [Time]  : terminalTime(t) => ~p16(t).
		Score(p_robot) = 90 <- ! t [Time]  : terminalTime(t) => p16(t).
	}
	
	// Translation of the TERMINAL sentences
	{
		! t [Time]  : terminalTime(t) <- p16(t).
	}
}
structure S : V {
	// Default structure elements:
	Start = 0
	Time = {0..20}
	ScoreType = {0..100}
	
	// Desired result
	Score = {p_robot->100}
	
	// Initial values for the fluent predicates
	I_p1 = {}
}
procedure main() {
	stdoptions.nbmodels=5
	printmodels(modelexpand(T,S))
}
