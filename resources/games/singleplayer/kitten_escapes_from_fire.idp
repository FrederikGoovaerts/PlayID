include <LTC>

LTCvocabulary V {
	// Default vocabulary elements (and types needed by the default elements)
	type Time isa nat
	Start : Time
	partial Next(Time) : Time
	type All constructed from {i0,i5,i15,i6,i14,i7,i8,i16,i1,i11,i10,i2,i3,i13,i4,i12,i9,kitten}
	type Action constructed from {move(All,All)}
	terminalTime(Time)
	type ScoreType isa nat
	type Player constructed from {p_?role,p_kitten}
	Score(Player) : ScoreType
	do(Time,Player,Action)
	
	// Vocabulary elements derived from GDL file
	field(All,All)
	succ(All,All)
	range(All)
	role(Time,All)
	neighbor(Time,All,All,All,All)
	smallerThan(Time,All,All)
	
	// LTC predicates for the fluent predicates
	position(Time,All,All,All)
	I_position(All,All,All)
	C_position(Time,All,All,All)
	
	round(Time,All)
	I_round(All)
	C_round(Time,All)
	
}
theory T: V {
	// Default theory elements:
	! a [Action] t [Time] p [Player]  : do(t,p,a) => ~terminalTime(t) & (? t2 [Time]  : Next(t) = t2).
	! p [Player] t [Time]  : ~terminalTime(t) & (? t2 [Time]  : Next(t) = t2) => (?=1 a [Action]  : do(t,p,a)).
	{
		! t [Time]  : Next(t) = t + 1 <- ~terminalTime(t) & (? t2 [Time]  : Next(t2) = t).
		Next(0) = 1.
	}
	
	// Inductive definitions for the fluent predicates
	{
		! a [All] a3 [All] a2 [All]  : position(Start,a,a2,a3) <- I_position(a,a2,a3).
		! a [All] a3 [All] t [Time] a2 [All]  : position(Next(t),a,a2,a3) <- C_position(t,a,a2,a3).
	}
	{
		! a [All]  : round(Start,a) <- I_round(a).
		! a [All] t [Time]  : round(Next(t),a) <- C_round(t,a).
	}
	
	// The fluent predicates' causations
	{
		! y [All] x [All] t [Time]  : C_round(t,x) <- round(t,y) & succ(y,x).
	}
	{
		! y [All] x [All] role [Player] t [Time]  : C_position(t,role,x,y) <- role(t,role) & do(t,role,move(x,y)).
	}
	
	// The static predicates' causations
	{
		! y [All] x [All] t [Time]  : smallerThan(t,x,y) <- succ(x,y).
		! y [All] z [All] x [All] t [Time]  : smallerThan(t,x,z) <- succ(x,y) & smallerThan(t,y,z).
	}
	{
		! y [All] x [All] a [All] t [Time]  : neighbor(t,x,y,a,y) <- range(y) & (succ(x,a) | succ(a,x)).
		! y [All] b [All] x [All] t [Time]  : neighbor(t,x,y,x,b) <- range(x) & (succ(y,b) | succ(b,y)).
	}
	
	// Translation of the LEGAL sentences
	! b [All] y [All] x [All] a [All] t [Time] role [All]  : do(t,p_?role,move(x,y)) => role(t,role) & field(x,y) & position(t,role,a,b) & neighbor(t,x,y,a,b).
	
	// Translation of the SCORE sentences
	{
		Score(p_kitten) = 100 <- ! t [Time]  : terminalTime(t) => position(t,kitten,i15,i4).
		Score(p_kitten) = 0 <- ! t [Time]  : terminalTime(t) => (? y [All] x [All] r [All] role [All]  : position(t,role,x,y) & role(t,role) & round(t,r) & smallerThan(t,x,r)).
		Score(p_kitten) = 0 <- ! t [Time]  : terminalTime(t) => round(t,i16).
	}
	
	// Translation of the TERMINAL sentences
	{
		! y [All] x [All] r [All] t [Time] role [All]  : terminalTime(t) <- position(t,role,x,y) & role(t,role) & round(t,r) & smallerThan(t,x,r).
		! t [Time]  : terminalTime(t) <- round(t,i16).
		! t [Time] role [All]  : terminalTime(t) <- position(t,role,i15,i4) & role(t,role).
	}
}
structure S : V {
	// Default structure elements:
	Start = 0
	Time = {0..20}
	ScoreType = {0..100}
	
	// Desired result
	Score = {p_kitten->100}
	
	// Initial values for the fluent predicates
	I_round = {i0}
	I_position = {kitten,i8,i2}
	
	// All values found in the static predicates
	field = {i9,i4;i9,i1;i5,i4;i5,i3;i5,i2;i12,i4;i5,i1;i12,i3;i13,i2;i13,i3;i4,i4;i13,i1;i6,i3;i6,i2;i13,i4;i6,i4;i1,i4;i1,i3;i6,i1;i1,i2;i1,i1;i2,i1;i14,i1;i7,i1;i7,i2;i7,i3;i7,i4;i3,i2;i10,i4;i3,i1;i10,i3;i10,i2;i10,i1;i2,i4;i2,i2;i2,i3;i8,i1;i8,i2;i8,i3;i8,i4;i15,i1;i15,i3;i4,i1;i11,i3;i15,i2;i4,i3;i15,i4;i4,i2;i11,i4;i3,i3;i3,i4;i12,i1;i12,i2}
	succ = {i10,i11;i0,i1;i1,i2;i15,i16;i3,i4;i2,i3;i5,i6;i4,i5;i9,i10;i7,i8;i11,i12;i12,i13;i6,i7;i13,i14;i14,i15;i8,i9}
	range = {i4;i3;i6;i5;i8;i7;i11;i10;i9;i13;i12;i15;i14;i2;i1}
}
procedure main() {
	stdoptions.nbmodels=5
	printmodels(modelexpand(T,S))
}
