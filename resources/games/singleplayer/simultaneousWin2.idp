include <LTC>

LTCvocabulary V {
	// Default vocabulary elements (and types needed by the default elements)
	type Time isa nat
	Start : Time
	partial Next(Time) : Time
	type All constructed from {i0,i1,i2,i3,i4}
	type Action constructed from {press(All,All,All,All)}
	terminalTime(Time)
	type ScoreType isa nat
	type Player constructed from {p_robot}
	Score(Player) : ScoreType
	do(Time,Player,Action)
	
	// Vocabulary elements derived from GDL file
	index(All)
	in(All,All,All)
	lightson4(Time)
	lightson3(Time)
	lightson2(Time)
	lightson1(Time)
	lightson14(Time)
	on(Time,All,All)
	lightson34(Time)
	lightson24(Time)
	lightson23(Time)
	lightson13(Time)
	lightson12(Time)
	
	// LTC predicates for the fluent predicates
	cell(Time,All,All,All)
	I_cell(All,All,All)
	C_cell(Time,All,All,All)
	
}
theory T: V {
	// Default theory elements:
	! a [Action] t [Time] p [Player]  : do(t,p,a) => ~terminalTime(t) & (? t2 [Time]  : Next(t) = t2).
	! p [Player] t [Time]  : ~terminalTime(t) & (? t2 [Time]  : Next(t) = t2) => (?=1 a [Action]  : do(t,p,a)).
	{
		! t [Time]  : Next(t) = t + 1 <- ~terminalTime(t) & (? t2 [Time]  : Next(t2) = t).
		Next(0) = 1.
	}
	
	// Inductive definitions for the fluent predicates
	{
		! a [All] a3 [All] a2 [All]  : cell(Start,a,a2,a3) <- I_cell(a,a2,a3).
		! a [All] a3 [All] t [Time] a2 [All]  : cell(Next(t),a,a2,a3) <- C_cell(t,a,a2,a3).
	}
	
	// The fluent predicates' causations
	{
		! y [All] x [All] t [Time]  : C_cell(t,x,y,i3) <- cell(t,x,y,i4).
		! y [All] x [All] yignore [All] xignore [All] t [Time]  : C_cell(t,x,y,i4) <- do(t,p_robot,press(xignore,yignore,x,y)).
		! y [All] x [All] t [Time]  : C_cell(t,x,y,i0) <- cell(t,x,y,i1).
		! y [All] x [All] t [Time]  : C_cell(t,x,y,i4) <- in(x,y,i3) & lightson3(t).
		! y [All] x [All] t [Time]  : C_cell(t,x,y,i4) <- in(x,y,i4) & lightson4(t).
		! y [All] x [All] yignore [All] xignore [All] t [Time]  : C_cell(t,x,y,i4) <- do(t,p_robot,press(x,y,xignore,yignore)).
		! y [All] x [All] t [Time]  : C_cell(t,x,y,i1) <- cell(t,x,y,i2).
		! y [All] x [All] t [Time]  : C_cell(t,x,y,i4) <- in(x,y,i1) & lightson1(t).
		! y [All] x [All] t [Time]  : C_cell(t,x,y,i4) <- in(x,y,i2) & lightson2(t).
		! y [All] x [All] t [Time]  : C_cell(t,x,y,i0) <- cell(t,x,y,i0).
		! y [All] x [All] t [Time]  : C_cell(t,x,y,i2) <- cell(t,x,y,i3).
	}
	
	// The static predicates' causations
	{
		! y [All] x [All] t [Time]  : on(t,x,y) <- cell(t,x,y,i1).
		! y [All] x [All] t [Time]  : on(t,x,y) <- cell(t,x,y,i2).
		! y [All] x [All] t [Time]  : on(t,x,y) <- cell(t,x,y,i3).
		! y [All] x [All] t [Time]  : on(t,x,y) <- cell(t,x,y,i4).
	}
	{
		! t [Time]  : lightson1(t) <- on(t,i1,i1) & on(t,i1,i2) & on(t,i2,i1) & on(t,i2,i2).
	}
	{
		! t [Time]  : lightson3(t) <- on(t,i1,i3) & on(t,i1,i4) & on(t,i2,i3) & on(t,i2,i4).
	}
	{
		! t [Time]  : lightson2(t) <- on(t,i3,i1) & on(t,i3,i2) & on(t,i4,i1) & on(t,i4,i2).
	}
	{
		! t [Time]  : lightson23(t) <- lightson2(t) & lightson3(t).
	}
	{
		! t [Time]  : lightson4(t) <- on(t,i3,i3) & on(t,i3,i4) & on(t,i4,i3) & on(t,i4,i4).
	}
	{
		! t [Time]  : lightson34(t) <- lightson3(t) & lightson4(t).
	}
	{
		! t [Time]  : lightson24(t) <- lightson2(t) & lightson4(t).
	}
	{
		! t [Time]  : lightson14(t) <- lightson1(t) & lightson4(t).
	}
	{
		! t [Time]  : lightson13(t) <- lightson1(t) & lightson3(t).
	}
	{
		! t [Time]  : lightson12(t) <- lightson1(t) & lightson2(t).
	}
	
	// Translation of the LEGAL sentences
	! x2 [All] y1 [All] x1 [All] t [Time] y2 [All]  : do(t,p_robot,press(x1,y1,x2,y2)) => index(x1) & index(y1) & index(x2) & index(y2).
	
	// Translation of the SCORE sentences
	{
		Score(p_robot) = 100 <- ! t [Time]  : terminalTime(t) => lightson13(t).
		Score(p_robot) = 100 <- ! t [Time]  : terminalTime(t) => lightson23(t).
		Score(p_robot) = 100 <- ! t [Time]  : terminalTime(t) => lightson14(t).
		Score(p_robot) = 100 <- ! t [Time]  : terminalTime(t) => lightson24(t).
		Score(p_robot) = 100 <- ! t [Time]  : terminalTime(t) => lightson34(t).
		Score(p_robot) = 100 <- ! t [Time]  : terminalTime(t) => lightson12(t).
		Score(p_robot) = 0 <- ! t [Time]  : terminalTime(t) => ~lightson12(t) & ~lightson13(t) & ~lightson14(t) & ~lightson23(t) & ~lightson24(t) & ~lightson34(t).
	}
	
	// Translation of the TERMINAL sentences
	{
		! t [Time]  : terminalTime(t) <- lightson14(t).
		! t [Time]  : terminalTime(t) <- lightson23(t).
		! t [Time]  : terminalTime(t) <- lightson24(t).
		! t [Time]  : terminalTime(t) <- lightson34(t).
		! t [Time]  : terminalTime(t) <- lightson12(t).
		! t [Time]  : terminalTime(t) <- lightson13(t).
	}
}
structure S : V {
	// Default structure elements:
	Start = 0
	Time = {0..20}
	ScoreType = {0..100}
	
	// Desired result
	Score = {p_robot->100}
	
	// Initial values for the fluent predicates
	I_cell = {i1,i1,i0;i1,i2,i0;i2,i4,i0;i2,i1,i0;i2,i2,i0;i2,i3,i0;i3,i3,i0;i4,i2,i0;i3,i4,i0;i4,i3,i0;i4,i4,i0;i3,i2,i0;i4,i1,i0;i1,i3,i0;i3,i1,i0;i1,i4,i0}
	
	// All values found in the static predicates
	in = {i1,i1,i1;i1,i2,i1;i2,i2,i1;i2,i1,i1;i2,i4,i3;i2,i3,i3;i3,i1,i2;i3,i2,i2;i1,i4,i3;i1,i3,i3;i4,i3,i4;i4,i4,i4;i3,i3,i4;i4,i1,i2;i3,i4,i4;i4,i2,i2}
	index = {i4;i3;i2;i1}
}
procedure main() {
	stdoptions.nbmodels=5
	printmodels(modelexpand(T,S))
}
