include <LTC>

LTCvocabulary V {
	// Default vocabulary elements (and types needed by the default elements)
	type Time isa nat
	Start : Time
	partial Next(Time) : Time
	type Action constructed from {a,c,b,d}
	terminalTime(Time)
	type ScoreType isa nat
	type Player constructed from {p_robot}
	Score(Player) : ScoreType
	do(Time,Player,Action)
	
	// Vocabulary elements derived from GDL file
	type All
	
	// LTC predicates for the fluent predicates
	h8(Time)
	I_h8()
	C_h8(Time)
	
	h5(Time)
	I_h5()
	C_h5(Time)
	
	h4(Time)
	I_h4()
	C_h4(Time)
	
	h7(Time)
	I_h7()
	C_h7(Time)
	
	h6(Time)
	I_h6()
	C_h6(Time)
	
	h1(Time)
	I_h1()
	C_h1(Time)
	
	h3(Time)
	I_h3()
	C_h3(Time)
	
	h2(Time)
	I_h2()
	C_h2(Time)
	
}
theory T: V {
	// Default theory elements:
	! a [Action] t [Time] p [Player]  : do(t,p,a) => ~terminalTime(t) & (? t2 [Time]  : Next(t) = t2).
	! p [Player] t [Time]  : ~terminalTime(t) & (? t2 [Time]  : Next(t) = t2) => (?=1 a [Action]  : do(t,p,a)).
	{
		! t [Time]  : Next(t) = t + 1 <- ~terminalTime(t) & (? t2 [Time]  : Next(t2) = t).
		Next(0) = 1.
	}
	
	// Inductive definitions for the fluent predicates
	{
		h8(Start) <- I_h8.
		! t [Time]  : h8(Next(t)) <- C_h8(t).
	}
	{
		h5(Start) <- I_h5.
		! t [Time]  : h5(Next(t)) <- C_h5(t).
	}
	{
		h4(Start) <- I_h4.
		! t [Time]  : h4(Next(t)) <- C_h4(t).
	}
	{
		h7(Start) <- I_h7.
		! t [Time]  : h7(Next(t)) <- C_h7(t).
	}
	{
		h6(Start) <- I_h6.
		! t [Time]  : h6(Next(t)) <- C_h6(t).
	}
	{
		h1(Start) <- I_h1.
		! t [Time]  : h1(Next(t)) <- C_h1(t).
	}
	{
		h3(Start) <- I_h3.
		! t [Time]  : h3(Next(t)) <- C_h3(t).
	}
	{
		h2(Start) <- I_h2.
		! t [Time]  : h2(Next(t)) <- C_h2(t).
	}
	
	// The fluent predicates' causations
	{
		! t [Time]  : C_h2(t) <- do(t,p_robot,a) & h1(t).
	}
	{
		! t [Time]  : C_h3(t) <- do(t,p_robot,b) & h1(t).
	}
	{
		! t [Time]  : C_h6(t) <- do(t,p_robot,a) & h5(t).
	}
	{
		! t [Time]  : C_h7(t) <- do(t,p_robot,b) & h5(t).
	}
	{
		! t [Time]  : C_h4(t) <- do(t,p_robot,c) & h1(t).
	}
	{
		! t [Time]  : C_h5(t) <- do(t,p_robot,d) & h2(t).
		! t [Time]  : C_h5(t) <- do(t,p_robot,d) & h4(t).
	}
	{
		! t [Time]  : C_h8(t) <- do(t,p_robot,b) & h7(t).
		! t [Time]  : C_h8(t) <- do(t,p_robot,a) & h6(t).
	}
	
	// Translation of the LEGAL sentences
	! t [Time]  : do(t,p_robot,b) => h5(t).
	! t [Time]  : do(t,p_robot,b) => h7(t).
	! t [Time]  : do(t,p_robot,b) => h1(t).
	! t [Time]  : do(t,p_robot,a) => h5(t).
	! t [Time]  : do(t,p_robot,a) => h6(t).
	! t [Time]  : do(t,p_robot,a) => h1(t).
	! t [Time]  : do(t,p_robot,c) => h1(t).
	! t [Time]  : do(t,p_robot,d) => h4(t).
	! t [Time]  : do(t,p_robot,d) => h2(t).
	
	// Translation of the SCORE sentences
	{
		Score(p_robot) = 100 <- ! t [Time]  : terminalTime(t) => h3(t).
		Score(p_robot) = 0 <- ! t [Time]  : terminalTime(t) => ~h3(t).
	}
	
	// Translation of the TERMINAL sentences
	{
		! t [Time]  : terminalTime(t) <- h8(t).
		! t [Time]  : terminalTime(t) <- h3(t).
	}
}
structure S : V {
	// Default structure elements:
	Start = 0
	Time = {0..20}
	ScoreType = {0..100}
	
	// Desired result
	Score = {p_robot->100}
	
	// Initial values for the fluent predicates
	I_h1 = {}
}
procedure main() {
	stdoptions.nbmodels=5
	printmodels(modelexpand(T,S))
}
