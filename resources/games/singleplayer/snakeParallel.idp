include <LTC>

LTCvocabulary V {
	// Default vocabulary elements (and types needed by the default elements)
	type Time isa nat
	Start : Time
	partial Next(Time) : Time
	type All constructed from {snake,i20,body,right,up,i0,left,i15,i5,i14,i6,i17,i7,i16,i8,i11,i1,i10,i2,i13,i3,i12,i4,i18,i9,i19,down}
	type Action constructed from {right(All),down(All),up(All),left(All)}
	terminalTime(Time)
	type ScoreType isa nat
	type Player constructed from {p_snake}
	Score(Player) : ScoreType
	do(Time,Player,Action)
	
	// Vocabulary elements derived from GDL file
	plus(All,All,All)
	index(All)
	dir(All)
	y(All)
	x(All)
	open(Time,All)
	collision(Time,All)
	moves(Time,All)
	
	// LTC predicates for the fluent predicates
	stepCount(Time,All)
	I_stepCount(All)
	C_stepCount(Time,All)
	
	cell(Time,All,All,All,All)
	I_cell(All,All,All,All)
	C_cell(Time,All,All,All,All)
	
}
theory T: V {
	// Default theory elements:
	! a [Action] t [Time] p [Player]  : do(t,p,a) => ~terminalTime(t) & (? t2 [Time]  : Next(t) = t2).
	! p [Player] t [Time]  : ~terminalTime(t) & (? t2 [Time]  : Next(t) = t2) => (?=1 a [Action]  : do(t,p,a)).
	{
		! t [Time]  : Next(t) = t + 1 <- ~terminalTime(t) & (? t2 [Time]  : Next(t2) = t).
		Next(0) = 1.
	}
	
	// Inductive definitions for the fluent predicates
	{
		! a [All]  : stepCount(Start,a) <- I_stepCount(a).
		! a [All] t [Time]  : stepCount(Next(t),a) <- C_stepCount(t,a).
	}
	{
		! a [All] a3 [All] a2 [All] a4 [All]  : cell(Start,a,a2,a3,a4) <- I_cell(a,a2,a3,a4).
		! a [All] a3 [All] t [Time] a2 [All] a4 [All]  : cell(Next(t),a,a2,a3,a4) <- C_cell(t,a,a2,a3,a4).
	}
	
	// The fluent predicates' causations
	{
		! y [All] x2 [All] i [All] x1 [All] t [Time]  : C_cell(t,i,x2,y,snake) <- cell(t,i,x1,y,snake) & do(t,p_snake,left(i)) & plus(i1,x2,x1).
		! y [All] x [All] i [All] t [Time]  : C_cell(t,i,x,y,snake) <- cell(t,i,x,y,snake) & ~moves(t,i).
		! y1 [All] x [All] i [All] t [Time] y2 [All]  : C_cell(t,i,x,y2,snake) <- cell(t,i,x,y1,snake) & do(t,p_snake,up(i)) & plus(i1,y1,y2).
		! y1 [All] x [All] i [All] t [Time] y2 [All]  : C_cell(t,i,x,y2,snake) <- cell(t,i,x,y1,snake) & do(t,p_snake,down(i)) & plus(i1,y2,y1).
		! y [All] x2 [All] i [All] x1 [All] t [Time]  : C_cell(t,i,x2,y,snake) <- cell(t,i,x1,y,snake) & do(t,p_snake,right(i)) & plus(i1,x1,x2).
		! y [All] x [All] i [All] t [Time]  : C_cell(t,i,x,y,body) <- cell(t,i,x,y,snake) & moves(t,i).
		! y [All] x [All] i [All] t [Time]  : C_cell(t,i,x,y,body) <- cell(t,i,x,y,body).
	}
	{
		! newCount [All] oldCount [All] t [Time]  : C_stepCount(t,newCount) <- stepCount(t,oldCount) & plus(i1,oldCount,newCount).
	}
	
	// The static predicates' causations
	{
		! y [All] x [All] i [All] t [Time]  : collision(t,i) <- cell(t,i,x,y,snake) & cell(t,i,x,y,body).
	}
	{
		! i [All] t [Time]  : moves(t,i) <- do(t,p_snake,right(i)).
		! i [All] t [Time]  : moves(t,i) <- do(t,p_snake,down(i)).
		! i [All] t [Time]  : moves(t,i) <- do(t,p_snake,left(i)).
		! i [All] t [Time]  : moves(t,i) <- do(t,p_snake,up(i)).
	}
	{
		! y [All] x [All] i [All] t [Time]  : open(t,i) <- x(x) & y(y) & index(i) & ~cell(t,i,x,y,snake) & ~cell(t,i,x,y,body).
	}
	
	// Translation of the LEGAL sentences
	! y [All] i [All] t [Time]  : do(t,p_snake,right(i)) => cell(t,i,i3,y,snake).
	! y [All] i [All] t [Time]  : do(t,p_snake,right(i)) => cell(t,i,i1,y,snake).
	! y [All] i [All] t [Time]  : do(t,p_snake,right(i)) => cell(t,i,i2,y,snake).
	! y [All] i [All] t [Time]  : do(t,p_snake,left(i)) => cell(t,i,i4,y,snake).
	! y [All] i [All] t [Time]  : do(t,p_snake,left(i)) => cell(t,i,i3,y,snake).
	! y [All] i [All] t [Time]  : do(t,p_snake,left(i)) => cell(t,i,i2,y,snake).
	! x [All] i [All] t [Time]  : do(t,p_snake,down(i)) => cell(t,i,x,i4,snake).
	! x [All] i [All] t [Time]  : do(t,p_snake,down(i)) => cell(t,i,x,i3,snake).
	! x [All] i [All] t [Time]  : do(t,p_snake,down(i)) => cell(t,i,x,i2,snake).
	! x [All] i [All] t [Time]  : do(t,p_snake,up(i)) => cell(t,i,x,i1,snake).
	! x [All] i [All] t [Time]  : do(t,p_snake,up(i)) => cell(t,i,x,i3,snake).
	! x [All] i [All] t [Time]  : do(t,p_snake,up(i)) => cell(t,i,x,i2,snake).
	
	// Translation of the SCORE sentences
	{
		Score(p_snake) = 100 <- ! t [Time]  : terminalTime(t) => ~open(t,i2).
		Score(p_snake) = 100 <- ! t [Time]  : terminalTime(t) => ~open(t,i1).
		Score(p_snake) = 0 <- ! t [Time]  : terminalTime(t) => open(t,i1) & open(t,i2).
	}
	
	// Translation of the TERMINAL sentences
	{
		! t [Time]  : terminalTime(t) <- stepCount(t,i20).
		! t [Time]  : terminalTime(t) <- collision(t,i1).
		! t [Time]  : terminalTime(t) <- collision(t,i2).
	}
}
structure S : V {
	// Default structure elements:
	Start = 0
	Time = {0..20}
	ScoreType = {0..100}
	
	// Desired result
	Score = {p_snake->100}
	
	// Initial values for the fluent predicates
	I_cell = {i2,i1,i1,snake;i1,i1,i1,snake}
	I_stepCount = {i0}
	
	// All values found in the static predicates
	y = {i4;i3;i2;i1}
	x = {i4;i3;i2;i1}
	index = {i2;i1}
	dir = {up;left;right;down}
	plus = {i1,i14,i15;i1,i0,i1;i1,i9,i10;i1,i15,i16;i1,i12,i13;i1,i2,i3;i1,i13,i14;i1,i1,i2;i1,i18,i19;i1,i16,i17;i1,i17,i18;i1,i19,i20;i1,i7,i8;i1,i8,i9;i1,i3,i4;i1,i11,i12;i1,i4,i5;i1,i10,i11;i1,i5,i6;i1,i6,i7}
}
procedure main() {
	stdoptions.nbmodels=5
	printmodels(modelexpand(T,S))
}
